\relax 
\select@language{english}
\@writefile{toc}{\select@language{english}}
\@writefile{lof}{\select@language{english}}
\@writefile{lot}{\select@language{english}}
\@writefile{loa}{\addvspace {10\p@ }}
\@writefile{loa}{\addvspace {10\p@ }}
\citation{principles}
\citation{armc}
\citation{metal}
\citation{mona}
\citation{cav06}
\citation{cav06}
\citation{tacas10}
\citation{popl13}
\citation{libvata}
\@writefile{toc}{\contentsline {chapter}{\numberline {1}Introduction}{3}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{introduction}{{1}{3}}
\@writefile{loa}{\addvspace {10\p@ }}
\citation{kozen}
\citation{ullman}
\@writefile{toc}{\contentsline {chapter}{\numberline {2}Preliminaries}{5}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{teorie}{{2}{5}}
\@writefile{toc}{\contentsline {section}{\numberline {2.1}Languages}{5}}
\@writefile{toc}{\contentsline {section}{\numberline {2.2}Finite Automata}{5}}
\newlabel{defFA}{{2.2}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.1}Nondeterministic Finite Automaton}{5}}
\newlabel{defNFA}{{2.2.1}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.1}{\ignorespaces An example of an NFA}}{6}}
\newlabel{pic_ex_nfa}{{2.1}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.2}Deterministic Finite Automaton}{6}}
\newlabel{defDFA}{{2.2.2}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.3}Run of a Finite Automaton}{6}}
\newlabel{defRun}{{2.2.3}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.2}{\ignorespaces An example of an DFA}}{7}}
\newlabel{pic_ex_dfa}{{2.2}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.4}Language of a Finite Automaton}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.5}Complete DFA}{7}}
\newlabel{defCompleteDFA}{{2.2.5}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.6}Operations over Finite Automata}{7}}
\newlabel{defAOps}{{2.2.6}{7}}
\@writefile{toc}{\contentsline {subsubsection}{Automata Union}{7}}
\newlabel{defAUnion}{{2.2.6}{7}}
\@writefile{toc}{\contentsline {subsubsection}{Automata Intersection}{7}}
\newlabel{defAInter}{{2.2.6}{7}}
\@writefile{toc}{\contentsline {subsubsection}{Subset construction}{8}}
\newlabel{subset}{{2.2.6}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.3}{\ignorespaces A simple example of NFA to DFA conversion via the subset construction with the reduction of inaccessible state. A small NFA with a small $\Sigma $ is shown here, but for larger NFA could state explosion occur.}}{8}}
\newlabel{pic_sub}{{2.3}{8}}
\@writefile{toc}{\contentsline {section}{\numberline {2.3}Regular Languages}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.1}Closure Properties}{9}}
\@writefile{loa}{\addvspace {10\p@ }}
\citation{cav06}
\citation{cav06}
\citation{tacas10}
\citation{popl13}
\citation{focs95}
\citation{cav06}
\@writefile{toc}{\contentsline {chapter}{\numberline {3}Checking Inclusion over NFA}{10}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapInclusion}{{3}{10}}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}Checking Inclusion with Antichains and Simulation}{10}}
\newlabel{sectionAntichain}{{3.1}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1.1}Antichains Algorithm Description}{10}}
\citation{tacas10}
\citation{tacas10}
\citation{popl13}
\newlabel{algAntichain}{{1}{11}}
\@writefile{loa}{\contentsline {algocf}{\numberline {1}{\ignorespaces Language inclusion checking with antichains and simulations}}{11}}
\@writefile{toc}{\contentsline {section}{\numberline {3.2}Checking Inclusion with Bisimulation up to Congruence}{11}}
\newlabel{sectionCongr}{{3.2}{11}}
\citation{tacas10}
\citation{tacas10}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.1}Congruence Algorithm Description}{12}}
\newlabel{subsectCongr}{{3.2.1}{12}}
\newlabel{algCongr}{{2}{12}}
\@writefile{loa}{\contentsline {algocf}{\numberline {2}{\ignorespaces Language equivalence checking with congruence}}{12}}
\citation{popl13}
\citation{popl13}
\citation{popl13}
\citation{popl13}
\@writefile{lof}{\contentsline {figure}{\numberline {3.1}{\ignorespaces  \rm  { \hspace  {0.1cm} The figure is based on an example from \cite  {tacas10}. It shows the procedure of checking language inclusion between two NFA using the mentioned approaches (which correspond to the labeled areas). The antichains algorithm reduces number of the generated states compared with the classical, e.g., $(p_2,\{q_1,q_2\})$ is not further explored because $(p_2,\{q_2\}) \sqsubseteq (p_2,\{q_1,q_2\})$. The optimization a) and b) are improvements of the antichains algorithm using simulation. The congruence algorithm also reduces the number of the generated states, so $(\{p_1,p_2\},\{q_1,q_2\})$ is not further explored because it is in the congruence closure of the set of visited pairs of states.}}}{13}}
\newlabel{automata}{{3.1}{13}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.2}Computation of Congruence Closure}{13}}
\newlabel{subsectionCongr}{{3.2.2}{13}}
\citation{popl13}
\citation{popl13}
\citation{popl13}
\@writefile{lof}{\contentsline {figure}{\numberline {3.2}{\ignorespaces The figure shows two NFA $\mathcal  {A}$, $\mathcal  {B}$ which are used in the examples describing computation of a congruence closure in Figure \ref  {figHKCRew} and in Figure \ref  {figHKCRewO}}}{14}}
\newlabel{figHKCex}{{3.2}{14}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.3}{\ignorespaces Derivation of the normal forms of the sets $\{x,y\}$ and $\{u\}$ using rewriting rules of the macrostates of a relation $R=\{(\{x\},\{u\}),(\{y,z\},\{u\})\}$.}}{14}}
\newlabel{figHKCRew}{{3.3}{14}}
\@writefile{toc}{\contentsline {subsubsection}{Optimization for Inclusion Checking}{14}}
\newlabel{congrOpt}{{3.2.2}{14}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.4}{\ignorespaces The figure shows the deriving of the normal form the set $\{u\}$ using rewriting rules of the elements of a relation $R=\{(\{x,u\},\{u\}),(\{y,z,u\},\{u\})\}$.}}{15}}
\newlabel{figHKCRewO}{{3.4}{15}}
\@writefile{loa}{\addvspace {10\p@ }}
\citation{brics}
\citation{libfa}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}Existing Finite Automata Libraries and the VATA Library}{16}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{libraries}{{4}{16}}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}Existing Finite Automata Libraries}{16}}
\newlabel{existinglibraries}{{4.1}{16}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.1}dk.brics.automaton}{16}}
\newlabel{brics}{{4.1.1}{16}}
\@writefile{toc}{\contentsline {subsubsection}{libfa}{16}}
\citation{fare}
\citation{kanthakN04}
\citation{rwth}
\citation{cav06}
\citation{tacas10}
\citation{libvata}
\@writefile{toc}{\contentsline {subsubsection}{Fare}{17}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.2}The RWHT FSA toolkit}{17}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.3}Implementation of the State-of-the-art Algorithms}{17}}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}VATA library}{17}}
\newlabel{VATA}{{4.2}{17}}
\citation{libvata}
\citation{libvata}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.1}Design}{18}}
\newlabel{sectionDesignVata}{{4.2.1}{18}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces The VATA library design. The image is taken from \cite  {libvata}.}}{18}}
\newlabel{picVataDesign}{{4.1}{18}}
\citation{libvata}
\citation{libvata}
\citation{libvata}
\citation{libvata}
\citation{libvata}
\@writefile{lof}{\contentsline {figure}{\numberline {4.2}{\ignorespaces The data structure for storing transitions of the tree automaton. There is a hash table (top-level look-up table) which map a state to the pointer to another hash table (transition cluster). Transition cluster maps a symbols of input alphabet to the pointer to the set of pointers to the tuples of states. The image is taken from \cite  {libvata}.}}{19}}
\newlabel{figExplicitTreeDataStr}{{4.2}{19}}
\@writefile{toc}{\contentsline {subsubsection}{Explicit Encoding}{19}}
\newlabel{sectionExplicitEnc}{{4.2.1}{19}}
\@writefile{toc}{\contentsline {subsubsection}{Semi-symbolic Encoding}{19}}
\citation{cav06}
\citation{tacas10}
\citation{libvata}
\@writefile{lot}{\contentsline {table}{\numberline {4.1}{\ignorespaces Table shows which operations are supported for the tree automata in the encodings implemented in the VATA library.}}{20}}
\newlabel{tabOp}{{4.1}{20}}
\@writefile{toc}{\contentsline {subsubsection}{Operations}{20}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.2}Extension for Finite Automata}{21}}
\@writefile{loa}{\addvspace {10\p@ }}
\citation{libvata}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}Design}{22}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{design}{{5}{22}}
\@writefile{toc}{\contentsline {section}{\numberline {5.1}Data Structures for Explicit Encoding of Finite Automata}{22}}
\newlabel{data structure explicit}{{5.1}{22}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1.1}Analysis}{22}}
\newlabel{analysis}{{5.1.1}{22}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1.2}Design of Data Structure for Transitions of NFA}{23}}
\citation{timbuk}
\@writefile{lof}{\contentsline {figure}{\numberline {5.1}{\ignorespaces The data structure for storing transitions of an NFA. There is a hash table (top-level look-up table) which maps a state of an NFA to the pointer to another hash table (transition cluster). The transition cluster maps symbols of the input alphabet to sets of states.}}{24}}
\newlabel{figExplicitFADataStr}{{5.1}{24}}
\@writefile{toc}{\contentsline {section}{\numberline {5.2}Data Structure for Initial and Final States}{24}}
\@writefile{toc}{\contentsline {section}{\numberline {5.3}Translation of the States and Symbols}{24}}
\newlabel{sectionTranslate}{{5.3}{24}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.2}{\ignorespaces The figure shows a principle of the translation of the input format to the internal representation by a hash table. The states (the left hash table) or of the symbols (the right hash table) of an NFA are mapped from strings to the integers.}}{25}}
\newlabel{figExplicitFATransl}{{5.2}{25}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.3}{\ignorespaces An NFA defined by text description in the Timbuk format}}{25}}
\newlabel{figTimbukFormat}{{5.3}{25}}
\@writefile{toc}{\contentsline {section}{\numberline {5.4}Use of the Timbuk Format}{25}}
\newlabel{usageTimbuk}{{5.4}{25}}
\@writefile{toc}{\contentsline {section}{\numberline {5.5}Algorithms for Basic Operations}{26}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.1}Union}{26}}
\@writefile{toc}{\contentsline {subsubsection}{Union of NFAs with Disjoint Sets of States}{26}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.2}Intersection}{26}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.3}Reversal}{26}}
\newlabel{algIntersection}{{3}{27}}
\@writefile{loa}{\contentsline {algocf}{\numberline {3}{\ignorespaces Algorithm for computing intersection of pair of NFA}}{27}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.4}Removing Unreachable States}{27}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.5}Removing Useless States}{27}}
\newlabel{algRemove}{{4}{28}}
\@writefile{loa}{\contentsline {algocf}{\numberline {4}{\ignorespaces Algorithm for removing the unreachable states of an NFA}}{28}}
\newlabel{algCandidate}{{5}{28}}
\@writefile{loa}{\contentsline {algocf}{\numberline {5}{\ignorespaces Algorithm for getting a witness in an NFA}}{28}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.6}Get Candidate}{28}}
\@writefile{loa}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {chapter}{\numberline {6}Implementation}{30}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{implementation}{{6}{30}}
\@writefile{toc}{\contentsline {section}{\numberline {6.1}Loading and Manipulation with Finite Automata in the Explicit Encoding}{30}}
\@writefile{toc}{\contentsline {section}{\numberline {6.2}Used Modules of the VATA Library}{30}}
\@writefile{toc}{\contentsline {subsubsection}{Parser and Serializer}{30}}
\@writefile{toc}{\contentsline {subsubsection}{Simulation}{31}}
\@writefile{toc}{\contentsline {subsubsection}{Utilities}{31}}
\@writefile{toc}{\contentsline {section}{\numberline {6.3}Macrostate Cache}{31}}
\newlabel{sectionCache}{{6.3}{31}}
\@writefile{lof}{\contentsline {figure}{\numberline {6.1}{\ignorespaces This figure shows the macrostate cache based on a hash table where the key is the sum of a macrostate and a value is a list of the macrostates.}}{32}}
\newlabel{figMacroCache}{{6.1}{32}}
\@writefile{toc}{\contentsline {section}{\numberline {6.4}Implementation of the Antichains Algorithm}{32}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.1}Ordering of an Antichain}{32}}
\citation{taocp}
\citation{taocp}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.2}Using Macrostate Cache}{33}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.3}Ordered Antichain}{33}}
\@writefile{toc}{\contentsline {section}{\numberline {6.5}Translation of an NFA into an LTS}{33}}
\@writefile{toc}{\contentsline {section}{\numberline {6.6}Implementation of the Bisimulation up to Congruence Algorithm}{33}}
\newlabel{sectionCongrImpl}{{6.6}{33}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.6.1}Exploring Product NFA}{34}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.6.2}Using Macrostate cache}{34}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.6.3}Computing Congruence Closure for Checking Equivalence}{34}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.6.4}Computing Congruence Closure for Inclusion Checking}{35}}
\@writefile{loa}{\addvspace {10\p@ }}
\citation{popl13}
\@writefile{toc}{\contentsline {chapter}{\numberline {7}Experimental Evaluation}{36}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{eval}{{7}{36}}
\@writefile{toc}{\contentsline {section}{\numberline {7.1}Evaluation of Algorithm Based on Antichains}{36}}
\@writefile{toc}{\contentsline {section}{\numberline {7.2}Evaluation of Algorithm Based on Bisimulation up to Congruence}{36}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.1}{\ignorespaces A comparison of the VATA library implementation of the antichains algorithm for tree automata in upward direction with the VATA library implementation of the antichains algorithm for NFA.}}{37}}
\newlabel{fig:figPlotAac}{{7.1}{37}}
\@writefile{lot}{\contentsline {table}{\numberline {7.1}{\ignorespaces The left table shows a comparison of the VATA library for tree automata with checking inclusion in the upward direction using the antichains algorithm with the implementation of the antichains algorithm for NFA and the right table shows the same comparison but with for the downward direction version of the antichains algorithm for tree automata optimized by a cache.}}{37}}
\newlabel{tabAac}{{7.1}{37}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.1}Comparison with OCaml Implementation}{37}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.2}{\ignorespaces The figure shows a comparison of the VATA library implementation of the antichains algorithm for tree automata in the downward direction using the cache optimization with the VATA library implementation of the antichains algorithm for NFA.}}{38}}
\newlabel{fig:figPlotAca}{{7.2}{38}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.3}{\ignorespaces  Comparison of the OCaml implementation of a congruence algorithm and the VATA library implementation of the algorithm.}}{38}}
\newlabel{fig:figGraphOCaml}{{7.3}{38}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.2}Comparison with Tree Automata Implementation of VATA Library}{38}}
\@writefile{lot}{\contentsline {table}{\numberline {7.2}{\ignorespaces This table gives a summary of the evaluation of the performance of the OCaml implementation of a congruence algorithm and VATA library implementation of the same algorithm.}}{39}}
\newlabel{tabOcaml}{{7.2}{39}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.4}{\ignorespaces The comparison of the VATA library implementation of the antichains algorithm for tree automata in the upward direction with the VATA library implementation of the congruence algorithm for NFA.}}{39}}
\newlabel{fig:figPlotAc}{{7.4}{39}}
\@writefile{lot}{\contentsline {table}{\numberline {7.3}{\ignorespaces The left table shows a comparison of the VATA library for tree automata with checking inclusion upward using the antichains algorithm with the implementation of the algorithm based on bisimulation up to congruence, and the right table shows the same comparison but for the downward version of the antichains algorithm optimized by cache.}}{40}}
\newlabel{tabAc}{{7.3}{40}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.5}{\ignorespaces The figure shows a comparison of the VATA library implementation of the anti\discretionary {-}{}{}chains algorithm for tree automata in the downward direction using the cache optimization with the VATA library implementation of the congruence algorithm for NFA.}}{40}}
\newlabel{fig:figPlotCa}{{7.5}{40}}
\@writefile{toc}{\contentsline {section}{\numberline {7.3}Comparison of the Algorithms for NFA}{40}}
\@writefile{lot}{\contentsline {table}{\numberline {7.4}{\ignorespaces This table shows the result of a comparison of the congruence algorithm and the antichain algorithm for NFA.}}{40}}
\newlabel{tabNFA}{{7.4}{40}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.6}{\ignorespaces The comparison of the VATA library implementation of the antichains algorithm for NFA (the left plot) with the VATA library implementation of the congruence algorithm for NFA (the right plot).}}{41}}
\newlabel{fig:figPlotNFA}{{7.6}{41}}
\@writefile{loa}{\addvspace {10\p@ }}
\bibstyle{plain}
\bibdata{literatura}
\@writefile{toc}{\contentsline {chapter}{\numberline {8}Conclusion}{42}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{concl}{{8}{42}}
\@writefile{loa}{\addvspace {10\p@ }}
\bibcite{tacas10}{1}
\bibcite{principles}{2}
\bibcite{fare}{3}
\bibcite{popl13}{4}
\bibcite{armc}{5}
\bibcite{metal}{6}
\bibcite{mona}{7}
\bibcite{focs95}{8}
\bibcite{ullman}{9}
\bibcite{kanthakN04}{10}
\bibcite{rwth}{11}
\bibcite{taocp}{12}
\bibcite{kozen}{13}
\bibcite{libvata}{14}
\bibcite{libfa}{15}
\bibcite{brics}{16}
\bibcite{timbuk}{17}
\bibcite{cav06}{18}
\@writefile{loa}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {chapter}{\numberline {A}Storage Medium}{45}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
